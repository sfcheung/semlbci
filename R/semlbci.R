#' @title Likelihood-Based Confidence Interval
#'
#' @description Finds the likelihood-based confidence intervals (LBCIs) for
#'  selected free parameters in an SEM output.
#'
#' @details [semlbci()] finds the positions of the selected parameters
#'  in the parameter table and then calls [ci_i_one()] once for each of
#'  them. Please see [ci_i_one()] and the functions it calls to find a
#'  confidence limit (currently [ci_bound_wn_i()]) for the technical
#'  details.
#'
#' The SEM output will first be checked by [check_sem_out()] to see
#' whether the model and the estimation method are supported.
#'
#' Currently supports [lavaan::lavaan-class] outputs only.
#'
#' @return A parameter table generated by
#'  [lavaan::parameterEstimates()], with the LBCIs for selected
#'  parameters added. Diagnostic information, if requested, will be
#'  included in the attributes
#'
#' @param sem_out The SEM output. Currently supports
#'  [lavaan::lavaan-class] outputs only.
#'
#' @param pars The positions of the parameters for which the LBCIs are
#'  to be searched. Use the position as appeared on the parameter
#'  tables of the `sem_out`. If `NULL`, the default, then LBCIs for
#'  all free parameters will be searched. Can also be a vector of
#'  strings to indicate the parameters on the parameter table. The
#'  parameters should be specified in [lavaan::lavaan()] syntax. The
#'  vector of strings will be converted by [syntax_to_i()] to
#'  parameter positions.
#'
#' @param include_user_pars Logical. Whether all user-defined parameters
#'  are automatically included when `pars` is not set. Default is `FALSE`.
#'  If `pars` is explicitly set, this argument will be ignored.
#'
#' @param ciperc The proportion of coverage for the confidence
#'  interval. Default is .95, requesting a 95 percent confidence
#'  interval.
#'
#' @param standardized If `TRUE`, the LBCI is for the standardized estimates.
#'
#' @param method The approach to be used to search for the confidence
#'  limits. Currently only `"wn"` (Wu-Neale-2012), the default, is
#'  supported.
#'
#' @param robust Whether the LBCI based on robust likelihood ratio
#'  test is to be found. Only `"satorra.2000"` in [lavaan::lavTestLRT()]
#'  is supported for now, implemented by the method proposed by Falk
#'  (2018). If `"none"`, the default, then likelihood ratio test based
#'  on maximum likelihood estimation will be used.
#'
#' @param ... Arguments to be passed to [ci_bound_wn_i()].
#'
#' @param parallel If `TRUE`, will use `parallel` to parallelize the search.
#'
#' @param ncpus The number of workers, if `parallel` is `TRUE`. Default is 2.
#'
#' @param use_pbapply If `TRUE`, `parallel` is `TRUE`, and `pbapply`
#'  is installed, [pbapply::pbapply()] will be used to display a
#'  progress bar when finding the intervals. Default is `TRUE`.
#'  Ignored if `parallel` is `FALSE`.
#'
#' @references
#'
#' Falk, C. F. (2018). Are robust standard errors the best approach
#' for interval estimation with nonnormal data in structural equation
#' modeling? *Structural Equation Modeling: A Multidisciplinary
#' Journal, 25*(2), 244-266.
#' \doi{10.1080/10705511.2017.1367254}
#'
#' Neale, M. C., & Miller, M. B. (1997). The use of likelihood-based confidence
#' intervals in genetic models. *Behavior Genetics, 27*(2), 113-120.
#' \doi{10.1023/A:1025681223921}
#'
#' Pritikin, J. N., Rappaport, L. M., & Neale, M. C. (2017). Likelihood-based
#' confidence intervals for a parameter with an upper or lower bound.
#' *Structural Equation Modeling: A Multidisciplinary Journal, 24*(3), 395-401.
#' \doi{10.1080/10705511.2016.1275969}
#'
#' @examples
#'
#' library(lavaan)
#' mod <-
#' "
#' m ~ a*x
#' y ~ b*m
#' ab := a * b
#' "
#' fit_med <- sem(mod, simple_med, fixed.x = FALSE)
#' p_table <- parameterTable(fit_med)
#' p_table
#' lbci_med <- semlbci(fit_med,
#'                     pars = c("m ~ x",
#'                              "y ~ m",
#'                              "ab :="))
#' lbci_med
#'
#' @export

semlbci <- function(sem_out,
                    pars = NULL,
                    include_user_pars = FALSE,
                    ciperc = .95,
                    standardized = FALSE,
                    method = "wn",
                    robust = "none",
                    ...,
                    parallel = FALSE,
                    ncpus = 2,
                    use_pbapply = TRUE) {
    if (!inherits(sem_out, "lavaan")) {
        stop("sem_out is not a supported object.")
      }
    sem_out_name <- deparse(substitute(sem_out))
    # Check sem_out
    sem_out_check <- check_sem_out(sem_out = sem_out, robust = robust)
    if (sem_out_check > 0) {
        msg <- paste0(paste(attr(sem_out_check, "info"), collapse = "\n"), "\n")
        warning(msg, immediate. = TRUE)
      }
    if (sem_out_check < 0) {
        msg <- paste0(paste(attr(sem_out_check, "info"), collapse = "\n"), "\n")
        stop(msg)
      }

    ptable <- as.data.frame(lavaan::parameterTable(sem_out))
    # Do not check for
    i <- ptable$free > 0
    #i_id <- ptable$id[i]
    i_id <- ptable$id
    i_id_free <- i_id[i]
    i_id_user <- i_id[(ptable$free == 0) & (ptable$user > 0)]
    # pars must be the position as in the lavaan parameterTable.
    if (!is.null(pars)) {
        if (is.character(pars)) {
            pars <- syntax_to_i(pars, sem_out)
          }
        i_selected <- i_id[pars]
      } else {
        # pars <- seq_len(sum(i))
        pars <- i_id_free
        if (include_user_pars && length(i_id_user) > 0) {
            pars <- c(pars, i_id_user)
          }
        i_selected <- i_id[pars]
      }
    npar <- sum(i)
    # KEEP for reference: environment(set_constraint) <- parent.frame()
    if (method == "wn") {
        f_constr <- eval(set_constraint(sem_out = sem_out, ciperc = ciperc),
                        envir = parent.frame())
      } else {
        f_constr <- NULL
      }

    # Compute the scaling factors
    if (robust == "satorra.2000") {
        sf_full_list <- lapply(pars,
                               scaling_factor3,
                               sem_out = sem_out,
                               standardized = standardized,
                               std_method = "internal",
                               sem_out_name = sem_out_name)
      } else {
        sf_full_list <- rep(NA, length(pars))
      }
    if (parallel) {
        cl <- parallel::makeCluster(ncpus)
        pkgs <- .packages()
        pkgs <- rev(pkgs)
        parallel::clusterExport(cl, "pkgs", envir = environment())
        parallel::clusterEvalQ(cl, {sapply(pkgs,
                        function(x) library(x, character.only = TRUE))
                      })
        parallel::clusterExport(cl, ls(envir = parent.frame()),
                                       envir = environment())
        if (requireNamespace ("pbapply", quietly = TRUE) &
            use_pbapply) {
            args_final <- utils::modifyList(list(...),
                                    list(npar = npar,
                                        sem_out = sem_out,
                                        standardized = standardized,
                                        debug = FALSE,
                                        f_constr = f_constr,
                                        method = method,
                                        ciperc = ciperc,
                                        robust = robust,
                                        sem_out_name = sem_out_name))
            # out_raw <- pbapply::pbmapply(
            #                     semlbci::ci_i,
            #                     i = pars,
            #                     sf_full = sf_full_list,
            #                     MoreArgs = args_final,
            #                     SIMPLIFY = FALSE,
            #                     cl = cl)
            pars2 <- rep(pars, each = 2)
            sf_full_list2 <- rep(sf_full_list, each = 2)
            which2 <- rep(c("lbound", "ubound"), times = length(pars))
            out_raw2 <- pbapply::pbmapply(
                                semlbci::ci_i_one,
                                i = pars2,
                                sf_full = sf_full_list2,
                                which = which2,
                                MoreArgs = args_final,
                                SIMPLIFY = FALSE,
                                cl = cl)
          } else {
            args_final <- utils::modifyList(list(...),
                                    list(npar = npar,
                                        sem_out = sem_out,
                                        standardized = standardized,
                                        debug = FALSE,
                                        f_constr = f_constr,
                                        method = method,
                                        ciperc = ciperc,
                                        robust = robust,
                                        sem_out_name = sem_out_name))
            # out_raw <- parallel::clusterMap(cl,
            #                   semlbci::ci_i,
            #                   i = pars,
            #                   sf_full = sf_full_list,
            #                   MoreArgs = args_final,
            #                   SIMPLIFY = FALSE)
            pars2 <- rep(pars, each = 2)
            sf_full_list2 <- rep(sf_full_list, each = 2)
            which2 <- rep(c("lbound", "ubound"), times = length(pars))
            out_raw2 <- parallel::clusterMap(cl,
                              semlbci::ci_i_one,
                              i = pars2,
                              sf_full = sf_full_list2,
                              which = which2,
                              MoreArgs = args_final,
                              SIMPLIFY = FALSE)
          }
        parallel::stopCluster(cl)
      } else {
        args_final <- utils::modifyList(list(...),
                                list(npar = npar,
                                    sem_out = sem_out,
                                    standardized = standardized,
                                    debug = FALSE,
                                    f_constr = f_constr,
                                    method = method,
                                    ciperc = ciperc,
                                    robust = robust,
                                    sem_out_name = sem_out_name))
        # out_raw <- mapply(
        #               ci_i,
        #               i = pars,
        #               sf_full = sf_full_list,
        #               MoreArgs = args_final,
        #               SIMPLIFY = FALSE)
        pars2 <- rep(pars, each = 2)
        sf_full_list2 <- rep(sf_full_list, each = 2)
        which2 <- rep(c("lbound", "ubound"), times = length(pars))
        out_raw2 <- mapply(
                      ci_i_one,
                      i = pars2,
                      sf_full = sf_full_list2,
                      which = which2,
                      MoreArgs = args_final,
                      SIMPLIFY = FALSE)
      }
    tmpfct <- function(x, y) {
        out <- mapply(c, x, y, SIMPLIFY = FALSE)
        out$method <- out$method[[1]]
        out$sf_full <- out$sf_full[[1]]
        out
      }
    tmp1 <- seq(1, 2 * length(pars), 2)
    tmp2 <- tmp1 + 1
    out_raw <- mapply(tmpfct,
                      out_raw2[tmp1],
                      out_raw2[tmp2],
                      SIMPLIFY = FALSE)
    out <- do.call(rbind, lapply(out_raw, function(x) x$bounds))
    # out <- do.call(rbind, out_raw)
    out_p <- ptable[, c("id", "lhs", "op", "rhs", "group", "label")]
    if (standardized) {
        pstd <- lavaan::standardizedSolution(sem_out)
        if (lavaan::lavTech(sem_out, "ngroups") == 1) {
            pstd$group <- 1
          }
        pstd$group[pstd$op == ":="] <- 0
        out_p <- merge(out_p, pstd[, c("lhs", "op", "rhs", "group", "est.std")],
                by = c("lhs", "op", "rhs", "group"), all.x = TRUE, sort = FALSE)
      } else {
        out_p$est <- ptable[, c("est")]
      }
    out_p$lbci_lb <- NA
    out_p$lbci_ub <- NA

    out_p[i_selected, "lbci_lb"] <- out[, 1]
    out_p[i_selected, "lbci_ub"] <- out[, 2]

    # Collect diagnostic info

    lb_diag <- lapply(out_raw, function(x) x$diags$lb_diag)
    ub_diag <- lapply(out_raw, function(x) x$diags$ub_diag)
    lb_time <- sapply(out_raw, function(x) x$times$lb_time)
    ub_time <- sapply(out_raw, function(x) x$times$ub_time)
    lb_out <- lapply(out_raw, function(x) x$ci_bound_i_out$lb_out)
    ub_out <- lapply(out_raw, function(x) x$ci_bound_i_out$ub_out)
    ci_method <- sapply(out_raw, function(x) x$method)
    scaling_factor <- lapply(out_raw, function(x) x$sf_full)
    p_names <- mapply(paste0, out_p[pars, "lhs"],
                              out_p[pars, "op"],
                              out_p[pars, "rhs"],
                      USE.NAMES = FALSE)
    names(lb_diag) <- p_names
    names(ub_diag) <- p_names
    names(lb_time) <- p_names
    names(ub_time) <- p_names
    names(lb_out) <- p_names
    names(ub_out) <- p_names
    names(ci_method) <- p_names
    names(scaling_factor) <- p_names

    attr(out_p, "lb_diag") <- lb_diag
    attr(out_p, "ub_diag") <- ub_diag
    attr(out_p, "lb_time") <- lb_time
    attr(out_p, "ub_time") <- ub_time
    attr(out_p, "lb_out") <- lb_out
    attr(out_p, "ub_out") <- ub_out
    attr(out_p, "ci_method") <- ci_method
    attr(out_p, "scaling_factor") <- scaling_factor
    attr(out_p, "call") <- match.call()

    # Append diagnostic info

    out_p[pars, "status_lb"] <- sapply(lb_diag, function(x) x$status)
    out_p[pars, "status_ub"] <- sapply(ub_diag, function(x) x$status)
    out_p[pars, "ci_org_lb"] <- sapply(lb_diag, function(x) x$ci_org_limit)
    out_p[pars, "ci_org_ub"] <- sapply(ub_diag, function(x) x$ci_org_limit)
    out_p[pars, "ratio_lb"] <- sapply(lb_diag, function(x) x$ci_limit_ratio)
    out_p[pars, "ratio_ub"] <- sapply(ub_diag, function(x) x$ci_limit_ratio)
    out_p[pars, "post_check_lb"] <-
                            sapply(lb_diag, function(x) x$fit_post_check)
    out_p[pars, "post_check_ub"] <-
                            sapply(ub_diag, function(x) x$fit_post_check)
    out_p[pars, "time_lb"] <- as.numeric(lb_time)
    out_p[pars, "time_ub"] <- as.numeric(ub_time)
    out_p[pars, "cl_lb"] <- sapply(lb_diag, function(x) x$ciperc_final)
    out_p[pars, "cl_ub"] <- sapply(ub_diag, function(x) x$ciperc_final)
    out_p[pars, "method"] <- ci_method
    if (robust != "none") {
        out_p[pars, "robust"] <- robust
      }

    class(out_p) <- c("semlbci", class(out_p))
    out_p
  }