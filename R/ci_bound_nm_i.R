#'@title Find the lower or upper bound for one parameter by the Neale-Miller-1997 approach
#'
#'@description Find the lower or upper bound for one parameter by the Neale-Miller-1997 approach.
#'
#'@details
#'
#' Currently supports \code{lavaan} output only.
#'
#'@return
#' The requested bound.
#' Can return the optimization history as an attribute.
#'
#' @param i The position of the target parameters as in the parameter table of lavaan.
#' @param npar The number of free parameters, including those constrained to be equal.
#' @param sem_out The fit object.
#' @param f_constr The constraint function generated by \code{set_constraint}.
#' @param which Whether the lower bound or the upper bound is to be found. Must be "lbound" or "ubound".
#' @param history If \code{TRUE}, return the full optimization output as an attribute. Default is \code{FALSE}.
#' @param perturbation_factor A number multiplied to the parameter estimates in the fit object.
#'                            Using the parameter estimates as starting values may lead to errors
#'                            in the first few iterations. Default is .90.
#' @param lb_var The lower bound for free parameters that are variances. Defautl is -Inf. This is not an admissible
#'                value but seems to be necessary when we need to find the LBCI for user-defined parameter.
#' @param wald_ci_start If TRUE and there are no equality constraints in the model, Wald confidence limit will
#'                       be used as the starting value for the target parameter if it is not a userd-defined paramter.
#' @param standardized If TRUE, the LBCI is for the standardized estimate. 
#' @param opts Options to be passed to \code{nloptr}
#' @param numDeriv_grad_method The method used in \code{numDeriv::grad}.
#' @param ... Optional arguments. Not used.
#' 
#'@examples
#' library(lavaan)
#' data(cfa_two_factors)
#' mod <-
#' "
#' f1 =~ x1 + x2 + a*x3
#' f2 =~ x4 + a*x5 + equal('f1=~x2')*x6
#' f1 ~~ 0*f2
#' asq := a^2
#' "
#' fit <- sem(mod, cfa_two_factors)
#'@export

ci_bound_nm_i <- function(i = NULL, 
                       npar = NULL, 
                       sem_out = NULL,
                       f_constr = NULL, 
                       which = NULL,
                       history = FALSE,
                       perturbation_factor = .9,
                       lb_var = -Inf,
                       wald_ci_start = TRUE,
                       standardized = FALSE,
                       opts = list(
                          "algorithm" = "NLOPT_LD_SLSQP",
                          "xtol_rel" = 1.0e-10,
                          "maxeval" = 1000,
                          "print_level" = 0),
                       numDeriv_grad_method = "Richardson",
                       ...) {
    k <- switch(which,
                lbound = 1,
                ubound = -1)
    p_table <- lavaan::parameterTable(sem_out) 
    npar <- sum(p_table$free > 0)
    i_op <- p_table[i, "op"]
    if (wald_ci_start & !sem_out@Model@eq.constraints) {
        if (i_op == ":=") {
              xstart <- set_start(i, sem_out, which)
              xstart <- xstart[xstart$free > 0, "est"]
            } else {
              if (standardized) {
                  xstart <- set_start(i, sem_out, which, standardized)
                  xstart <- xstart[xstart$free > 0, "est"]
                } else {
                  xstart <- set_start(i, sem_out, which)
                  xstart <- xstart[xstart$free > 0, "est"]
                }
            } 
      } else {
        xstart <- perturbation_factor * lavaan::coef(sem_out)
      }
    # Check if the parameter is a user-defined parameter
    if (standardized && (i_op %in% c("=~", "~", "~~", ":="))) {
        # TODO: Not ready
        # Get the name of the defined parameter
        i_name <- p_table[i, "label"]
        # The function to be minimized.
        i_depend <- find_dependent(i, sem_out = sem_out, standardized = TRUE)
        # The function to be minimized.
        param_i <- rep(NA, npar)
        start0 <- lavaan::parameterTable(sem_out)
        lbci_b_f <- function(param_depend, sem_out, debug, lav_warn) {
            force(i_depend)
            force(param_i)
            force(i_name)
            force(start0)
            if (is.null(attr(param_depend, "refit"))) {
                param_i[i_depend] <- param_depend
                start1 <- start0[!(start0$op == ":="), ]
                start1[i_depend, "free"] <- 0
                start1[i_depend, "ustart"] <- 0
                start1[i_depend, "est"] <- param_depend
                fit2 <- lavaan::update(sem_out, start1)
                f_i_shared <<- fit2
                p_table2 <- lavaan::parameterTable(fit2)
                p_table2$esty <- p_table2$est
              } else {
                p_table2 <- lavaan::parameterTable(f_i_shared)
                p_table2[i_depend, "est"] <- param_depend
                p_table2$esty <- p_table2$est
              }
            # start1 <- start0[start0$op != "==", ]
            # start1[i_depend, "est"] <- param_i
            sem_out2 <- sem_out
            start3 <- merge(p_table, p_table2[, c("lhs", "op", "rhs", "esty")], 
                        by = c("lhs", "op", "rhs"), all.x = TRUE, all.y = FALSE,
                        sort = FALSE)
            start3$est <- start3$esty
            start3$esty <- NULL
            sem_out2@ParTable <- as.list(start3)
            sem_model <- sem_out2@Model
            sem_model <- update_model(sem_model, 
                                      start3[start3$free > 0, "est"] )
            sem_out2@Model <- sem_model
            std0 <- lavaan::standardizedSolution(sem_out2,
                                            type = "std.all",
                                            se = FALSE,
                                            zstat = FALSE,
                                            pvalue = FALSE,
                                            ci = FALSE,
                                            remove.eq = FALSE,
                                            remove.ineq = FALSE,
                                            remove.def = FALSE,
                                            output = "data.frame")
            k * std0[i, "est.std"]
          }
        lbci_b_grad <- function(param_depend, sem_out, debug, lav_warn) {
            param_depend_g <- param_depend
            attr(param_depend_g, "refit") <- FALSE 
            lavaan::lav_func_gradient_simple(lbci_b_f, param_depend_g, sem_out = sem_out, 
                                    debug = debug, lav_warn = lav_warn)
          }
        f_constr = set_constraint_nm(i_depend, sem_out, get_fit_from_prent = TRUE)
        # Set shared variables
        f_i_shared <- sem_out
        f_i_free_shared <- sem_out
        # lbci_b_grad <- NULL
        fit_lb <- rep(-Inf, length(i_depend))
        fit_ub <- rep( Inf, length(i_depend))
        fit_lb[find_variance_in_free(sem_out)[i_depend]] <- lb_var
        xstart <-  xstart[i_depend]
      }
    if (i_op == ":=") {
        if (standardized) {
          } else {
            # Get the name of the defined parameter
            i_name <- p_table[i, "label"]
            # The function to be minimized.
            i_depend <- find_dependent(i, sem_out = sem_out, standardized = FALSE)
            # The function to be minimized.
            param_i <- rep(NA, npar)
            lbci_b_f <- function(param_depend, sem_out, debug, lav_warn) {
                force(i_depend)
                force(param_i)
                force(i_name)
                param_i[i_depend] <- param_depend
                k * sem_out@Model@def.function(param_i)[i_name]
              }
            lbci_b_grad <- function(param_depend, sem_out, debug, lav_warn) {
                numDeriv::grad(lbci_b_f, param_depend, sem_out = sem_out, 
                                        debug = debug, lav_warn = lav_warn)
              }
            f_constr = set_constraint_nm(i_depend, sem_out)
            # Set shared variables
            f_i_shared <- sem_out
            f_i_free_shared <- sem_out
            # lbci_b_grad <- NULL
            fit_lb <- rep(-Inf, length(i_depend))
            fit_ub <- rep( Inf, length(i_depend))
            fit_lb[find_variance_in_free(sem_out)[i_depend]] <- lb_var
            xstart <-  xstart[i_depend]
          }
      } else {
        if (standardized) {
          } else {
            # The function to be minimized.
            lbci_b_f <- function(p_f, sem_out, debug, lav_warn) {
                k * p_f
              }
            # The gradient of the function to be minimized
            lbci_b_grad <- function(p_f, sem_out, debug, lav_warn) {
                force(i)
                lavaan::lavTech(f_i_free_shared, "gradient")[i]
              }
            f_constr = set_constraint_nm(i, sem_out)
            # Set shared variables
            f_i_shared <- sem_out
            f_i_free_shared <- sem_out
            # lbci_b_grad <- NULL
            fit_lb <- -Inf
            fit_ub <-  Inf
            xstart <-  xstart[i]
          }
      }
    # fit_lb <- rep(-Inf, npar)
    # fit_lb[find_variance_in_free(sem_out)] <- lb_var
    out <- nloptr::nloptr(
                        x0 = xstart, 
                        eval_f = lbci_b_f, 
                        lb = fit_lb, # To-Do: Check
                        ub = fit_ub, # To-Do: Check
                        eval_grad_f = lbci_b_grad,
                        eval_g_eq = f_constr,
                        opts = opts,
                        sem_out = sem_out,
                        lav_warn = FALSE,
                        debug = FALSE)
    bound <- k * out$objective

    # Check whether admissible
    start0 <- lavaan::parameterTable(sem_out)
    i_free <- find_free(sem_out)
    if (standardized) {
        fit_post_check <- lavaan::lavInspect(f_i_free_shared, "post.check")
      } else {
        if (i_op == ":=") {
            start0[which(i_free)[i_depend], "est"] <- out$solution
          } else {
            start0[i_free, "est"] <- out$solution
          }
        fit_final <- lavaan::update(sem_out, start = start0, do.fit = FALSE,
                                    check.start = TRUE,
                                    check.post = TRUE,
                                    check.vcov = TRUE)
        fit_post_check <- lavaan::lavInspect(fit_final, "post.check")
      }
    if (!fit_post_check) {
        bound <- NA
        warning("Optimization converged but the final solution is not admissible.")
      }
    if (history) {
        attr(bound, "history") <- out
      }
    bound
  }
