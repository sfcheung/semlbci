#'@title Find the lower or upper bound for one parameter by the Neale-Miller-1997 approach
#'
#'@description Find the lower or upper bound for one parameter by the Neale-Miller-1997 approach.
#'
#'@details
#'
#' Currently supports \code{lavaan} output only.
#'
#'@return
#' The requested bound.
#' Can return the optimization history as an attribute.
#'
#' @param i The position of the target parameters as in the parameter table of lavaan.
#' @param npar The number of free parameters, including those constrained to be equal.
#' @param sem_out The fit object.
#' @param f_constr The constraint function generated by \code{set_constraint}.
#' @param which Whether the lower bound or the upper bound is to be found. Must be "lbound" or "ubound".
#' @param history If \code{TRUE}, return the full optimization output, stored in the [`diag`] attribute.
#'                Default is \code{FALSE}. This argument is no longer used. [`verbose`] will be used instead.
#' @param perturbation_factor A number multiplied to the parameter estimates in the fit object.
#'                            Using the parameter estimates as starting values may lead to errors
#'                            in the first few iterations. Default is .90.
#' @param lb_var The lower bound for free parameters that are variances. Defautl is -Inf. This is not an admissible
#'                value but seems to be necessary when we need to find the LBCI for user-defined parameter.
#' @param wald_ci_start If TRUE and there are no equality constraints in the model, Wald confidence limit will
#'                       be used as the starting value for the target parameter if it is not a userd-defined paramter.
#' @param standardized If TRUE, the LBCI is for the standardized estimate. 
#' @param opts Options to be passed to \code{nloptr}
#' @param test_generic If [`TRUE`], will use the work-in-progress generic functions. Default is [`TRUE`].
#'                     The generic functions are now the default and other functions should not be used.
#'                     Therefore, this argument will be ignored.
#' @param ciperc The proportion of coverage for the confidence interval. Default
#'               is .95.
#' @param ci_limit_ratio_tol The tolerance for the ratio of a to b, where a is the distance between an LBCI limit and the 
#'               point estimate, and the b is the distance between the original [`lavaan`] CI limit (by default the Wald CI)
#'               and the point estimate. If the ratio is larger than this value, a warning is set in the status code.
#'               Default is 1.5.
#' @param verbose If [`TRUE`], will store more diagnostic information in the attribute [`diag`].GlobalEnv
#'                Default is [`FALSE`].
#' @param ... Optional arguments. Not used.
#' 
#'@examples
#' library(lavaan)
#' data(cfa_two_factors)
#' mod <-
#' "
#' f1 =~ x1 + x2 + a*x3
#' f2 =~ x4 + a*x5 + equal('f1=~x2')*x6
#' f1 ~~ 0*f2
#' asq := a^2
#' "
#' fit <- sem(mod, cfa_two_factors)
#'@export

ci_bound_nm_i <- function(i = NULL, 
                       npar = NULL, 
                       sem_out = NULL,
                       f_constr = NULL, 
                       which = NULL,
                       history = FALSE,
                       perturbation_factor = .9,
                       lb_var = -Inf,
                       wald_ci_start = TRUE,
                       standardized = FALSE,
                       opts = list(),
                       test_generic = TRUE,
                       ciperc = .95,
                       ci_limit_ratio_tol = 1.5,
                       verbose = FALSE,
                       ...) {
    # The generic functions are now always used.
    # The other functions will be deleted soon.
    test_generic <- TRUE
    k <- switch(which,
                lbound = 1,
                ubound = -1)
    p_table <- lavaan::parameterTable(sem_out) 
    npar <- sum(p_table$free > 0)
    i_op <- p_table[i, "op"]

    # Get original point estiamte and CI
    if (standardized) {
        p_est <- lavaan::standardizedSolution(sem_out,
                    type = "std.all",
                    se = TRUE,
                    zstat = FALSE,
                    pvalue = FALSE,
                    ci = TRUE,
                    remove.eq = FALSE,
                    remove.ineq = FALSE,
                    remove.def = FALSE,
                    output = "data.frame")
        i_est <- p_est[i, "est.std"]
        i_org_ci_lower <- p_est[i, "ci.lower"]
        i_org_ci_upper <- p_est[i, "ci.upper"]
      } else {
        p_est <- lavaan::parameterEstimates(sem_out,
                                            se = TRUE,
                                            zstat = FALSE,
                                            fmi = FALSE,
                                            rsquare = TRUE,
                                            output = "data.frame")
        i_est <- p_est[i, "est"]
        i_org_ci_lower <- p_est[i, "ci.lower"]
        i_org_ci_upper <- p_est[i, "ci.upper"]
      }
    # TO DELETE
    # if (standardized) {
    #     i_est <- lavaan::standardizedSolution(sem_out,
    #                 type = "std.all",
    #                 se = TRUE,
    #                 zstat = FALSE,
    #                 pvalue = FALSE,
    #                 ci = TRUE,
    #                 remove.eq = FALSE,
    #                 remove.ineq = FALSE,
    #                 remove.def = FALSE,
    #                 output = "data.frame")[i, "est.std"]
    #   } else {
    #     i_est <- p_table[i, "est"]
    #   }
    if (wald_ci_start) {
        if (i_op == ":=") {
              xstart <- set_start(i, sem_out, which)
              xstart <- xstart[xstart$free > 0, "est"]
            } else {
              if (standardized) {
                  xstart <- set_start(i, sem_out, which, standardized)
                  xstart <- xstart[xstart$free > 0, "est"]
                } else {
                  xstart <- set_start(i, sem_out, which)
                  xstart <- xstart[xstart$free > 0, "est"]
                }
            } 
      } else {
        xstart <- perturbation_factor * lavaan::coef(sem_out)
      }
    if (test_generic) {
        # Find the label if the targe parameter is a user defined parameter
        if (i_op == ":=") {
            i_name <- p_table[i, "label"]
          } else {
            i_name <- NA
          }
        # Find dependent parameters
        i_depend <- find_dependent(i, sem_out = sem_out,
                                   standardized = standardized)
        # Check if the model has any linear equality constraints
        if (sem_out@Model@eq.constraints) {
            eq_K  <- sem_out@Model@eq.constraints.K
            eq_k0 <- sem_out@Model@eq.constraints.k0
            i_in_eq <- apply(eq_K, 1, function(x) any(sort(unique(x)) != c(0, 1)))
            i_in_eq_label <- p_table[which(i_in_eq), "plabel"]
            npar_reduced <- ncol(eq_K)
            i_depend_reduced <- which(apply(eq_K[i_depend, seq_len(npar_reduced), drop = FALSE] != 0, 2, any))
          } else {
            eq_K  <- NULL
            eq_k0 <- NULL
            i_in_eq <- NULL
            i_in_eq_label <- NULL
            npar_reduced <- npar
            i_depend_reduced <- i_depend
          }
        # Set starting value
        i_depend_signed <- find_dependent(i, sem_out = sem_out,
                                   standardized = standardized, signed = TRUE)
        # Expand the vectors by labels
        i_exp <- enforce_eq_by_label(i_depend, p_table)
        i_exp_target <- i_exp$i_exp_target
        i_exp_source <- i_exp$i_exp_source
        # Set starting values
        if (wald_ci_start) {
            xstart0 <- p_table
            # xstart0$ci.lower <- xstart0$est
            # xstart0$ci.upper <- xstart0$est
            xstart0$lbcistart <- xstart0$est
            zcrit <- qnorm(1 - (1 - ciperc)/2)
            xstart0[i_depend, "lbcistart"] <- xstart0[i_depend, "est"] + 
                                            -1 * k * i_depend_signed * zcrit * xstart0[i_depend, "se"]
            xstart0[i_exp_target, "lbcistart"] <- xstart0[i_exp_source, "lbcistart"] 
            xstart <- xstart0[xstart0$free > 0, "lbcistart"]
            if (!is.null(eq_K)) {
                # Reduce the prarmeter
                xstart <- as.numeric((xstart - eq_k0) %*% eq_K)
              }
          } else {
            xstart <- perturbation_factor * lavaan::coef(sem_out)            
          }
        # Setup the shared environment
        start0 <- lavaan::parameterTable(sem_out)
        envir0 <- new.env()
        assign("f_i_shared", sem_out, envir = envir0)
        assign("f_i_free_shared", sem_out, envir = envir0)
        param_i <- rep(NA, npar)
        # Define lbci_b_f
        lbci_b_f <- function(param_depend, sem_out, debug, lav_warn) {
            force(i)
            force(k)
            force(i_depend)
            force(i_name)
            force(start0)
            force(envir0)
            force(param_i)
            force(eq_k0)
            force(eq_K)
            force(i_in_eq_label)
            force(i_exp)
            i_exp_target <- i_exp$i_exp_target
            i_exp_source <- i_exp$i_exp_source
            param_i[i_depend] <- param_depend
            param_i[i_exp_target] <- param_i[i_exp_source]

            # Enforce linear equality constraints
            if (!is.null(eq_K)) {
                # stop("Not yet work for models with equality constraints")
                param_i_reduced <- rep(0, npar_reduced)
                param_i_reduced[i_depend_reduced] <- param_depend
                param_i <- as.numeric(eq_K %*% matrix(param_i_reduced, npar_reduced, 1) + eq_k0)
                param_depend <- param_i[i_depend]
              }
                
            if (is.null(attr(param_depend, "refit"))) {
                start1 <- start0[!(start0$op == ":="), ]
                start1[i_depend, "free"] <- 0
                start1[i_depend, "ustart"] <- 0
                start1[i_depend, "est"] <- param_depend
                start1[i_exp_target, "free"] <- start1[i_exp_source, "free"] 
                start1[i_exp_target, "ustart"] <- start1[i_exp_source, "ustart"] 
                start1[i_exp_target, "est"] <- start1[i_exp_source, "est"] 
                start1 <- start1[!((start1$lhs %in% i_in_eq_label) |
                                   (start1$rhs %in% i_in_eq_label)), ]
                fit2 <- lavaan::update(sem_out, start1,
                                       baseline = FALSE,
                                       h1 = FALSE)
                assign("f_i_shared", fit2, envir0)
                # p_table2 <- lavaan::parameterTable(fit2)
                # p_table2$esty <- p_table2$est
              } else {
                # p_table2 <- lavaan::parameterTable(envir0$f_i_shared)
                # p_table2[i_depend, "est"] <- param_depend
                # p_table2[i_exp_target, "est"] <- p_table2[i_exp_source, "est"] 
                # p_table2$esty <- p_table2$est
              }
            if (standardized) {
                # p_table2 <- lavaan::parameterTable(envir0$f_i_shared)
                # p_table2 <- as.data.frame(envir0$f_i_shared@ParTable)
                # p_table2[i_depend, "est"] <- param_depend
                # p_table2[i_exp_target, "est"] <- p_table2[i_exp_source, "est"] 
                # p_table2$esty <- p_table2$est

                p_table2 <- envir0$f_i_shared@ParTable
                p_table2$est[i_depend] <- param_depend
                p_table2$est[i_exp_target] <- p_table2$est[i_exp_source] 

                # sem_out2 <- sem_out
                # p_table2 <- as.data.frame(envir0$f_i_shared@ParTable)
                # k1 <- paste0(p_table$lhs, p_table$op, p_table$rhs)
                # k2 <- paste0(p_table2$lhs, p_table2$op, p_table2$rhs)
                # start3 <- p_table
                # start3[match(k2, k1), "est"] <- p_table2[k2 %in% k1, "est"]
                # sem_out2@ParTable <- as.list(start3)
                # sem_model <- sem_out2@Model
                # sem_model <- update_model(sem_model, 
                #                           start3[start3$free > 0, "est"] )
                # sem_out2@Model <- sem_model
                # sem_out2@Model@GLIST <- envir0$f_i_shared@Model@GLIST

                sem_out2 <- sem_out

                # start3 <- merge(p_table, p_table2[, c("lhs", "op", "rhs", "esty")], 
                #             by = c("lhs", "op", "rhs"), all.x = TRUE, all.y = FALSE,
                #             sort = FALSE)
                # start3$est <- start3$esty
                # start3$esty <- NULL

                start3 <- p_table
                k1 <- paste0(p_table$lhs, p_table$op, p_table$rhs)
                k2 <- paste0(p_table2$lhs, p_table2$op, p_table2$rhs)
                start3 <- p_table
                start3[match(k2, k1), "est"] <- p_table2$est[k2 %in% k1]
                sem_out2@ParTable <- as.list(start3)
                sem_model <- sem_out2@Model
                sem_model <- update_model(sem_model, 
                                          start3[start3$free > 0, "est"] )
                sem_out2@Model <- sem_model
                std0 <- lavaan::standardizedSolution(sem_out2,
                                                type = "std.all",
                                                se = FALSE,
                                                zstat = FALSE,
                                                pvalue = FALSE,
                                                ci = FALSE,
                                                remove.eq = FALSE,
                                                remove.ineq = FALSE,
                                                remove.def = FALSE,
                                                output = "data.frame")
                # return(k * std0[i, "est.std"])
                return(k * ( std0[i, "est.std"] - i_est))
              } else {
                if (i_op == ":=") {
                  # return(k * sem_out@Model@def.function(param_i)[i_name])
                  return(k * (sem_out@Model@def.function(param_i)[i_name] - i_est))
                } else {
                  # return(k * p_table2[i, "est"])
                  # tmp <- mapply(function(x, y, z) {
                  #     z[y[x == i]]
                  #     },
                  #       sem_out@Model@x.free.idx,
                  #       sem_out@Model@m.free.idx, 
                  #       envir0$f_i_shared@Model@GLIST)
                  # tmp <- unlist(tmp)
                  # return(k * (tmp - i_est))
                  return(k * (envir0$f_i_shared@ParTable$est[i] - i_est))
                  # return(k * (p_table2[i, "est"] - i_est))
                }
              }
          }
        # Define constraint function
        qcrit <- stats::qchisq(ciperc, 1)
        fmin <- lavaan::lavTech(sem_out, "optim")$fx
        n <- lavaan::lavTech(sem_out, "nobs")
        target <- fmin + qcrit / (2 * n)
        f_constr <- function(param_depend, sem_out, debug, lav_warn) {
            force(i_depend)
            force(envir0)
            force(target)
            f_obj <- target
            fit2 <- envir0$f_i_shared
            f_obj <- lavaan::lavTech(fit2, "optim")$fx - target

            # Pre-modification fx and grad
            fx_tmp <- lavaan::lavTech(fit2, "optim")$fx 
            g_tmp <- lavaan::lavTech(fit2, "gradient")
  
            # Update
            fit3 <- sem_out
            fit3@Model@GLIST <- fit2@Model@GLIST
            f_jac <- rbind(lavaan::lavTech(fit3, "gradient")[i_depend])

            g3_tmp <- lavaan::lavTech(fit3, "gradient")
            if (!is.null(eq_K)) {
                # stop("Not yet work for models with equality constraints")
                g3_tmp <- (g3_tmp - eq_k0) %*% eq_K
              }
            list(constraints = rbind(f_obj),
                 jacobian = rbind(g3_tmp[i_depend_reduced])
              )
          }
        # Define gradient function
        lbci_b_grad <- function(param_depend, sem_out, debug, lav_warn) {
            param_depend_g <- param_depend
            attr(param_depend_g, "refit") <- FALSE
            lavaan::lav_func_gradient_simple(lbci_b_f, param_depend_g, 
                                    sem_out = sem_out, 
                                    debug = debug, 
                                    lav_warn = lav_warn)
          }
        # Setup bound
        fit_lb <- rep(-Inf, length(i_depend))
        fit_ub <- rep( Inf, length(i_depend))
        fit_lb[find_variance_in_free(sem_out)[i_depend]] <- lb_var
        xstart <-  xstart[i_depend_reduced]
      }
    if (standardized && (i_op %in% c("=~", "~", "~~", ":=")) && !test_generic) {
        # TODO: Not ready
        # Get the name of the defined parameter
        i_name <- p_table[i, "label"]
        # The function to be minimized.
        i_depend <- find_dependent(i, sem_out = sem_out, standardized = TRUE)
        # The function to be minimized.
        param_i <- rep(NA, npar)
        start0 <- lavaan::parameterTable(sem_out)
        envir0 <- new.env()
        assign("f_i_shared", sem_out, envir = envir0)
        assign("f_i_free_shared", sem_out, envir = envir0)
        # f_i_shared <- sem_out
        # f_i_free_shared <- sem_out
        lbci_b_f <- function(param_depend, sem_out, debug, lav_warn) {
            force(i_depend)
            force(param_i)
            force(i_name)
            force(start0)
            force(envir0)
            if (is.null(attr(param_depend, "refit"))) {
                param_i[i_depend] <- param_depend
                start1 <- start0[!(start0$op == ":="), ]
                start1[i_depend, "free"] <- 0
                start1[i_depend, "ustart"] <- 0
                start1[i_depend, "est"] <- param_depend
                fit2 <- lavaan::update(sem_out, start1)
                # f_i_shared <<- fit2
                assign("f_i_shared", fit2, envir0)
                p_table2 <- lavaan::parameterTable(fit2)
                p_table2$esty <- p_table2$est
              } else {
                p_table2 <- lavaan::parameterTable(envir0$f_i_shared)
                p_table2[i_depend, "est"] <- param_depend
                p_table2$esty <- p_table2$est
              }
            # start1 <- start0[start0$op != "==", ]
            # start1[i_depend, "est"] <- param_i
            sem_out2 <- sem_out
            start3 <- merge(p_table, p_table2[, c("lhs", "op", "rhs", "esty")], 
                        by = c("lhs", "op", "rhs"), all.x = TRUE, all.y = FALSE,
                        sort = FALSE)
            start3$est <- start3$esty
            start3$esty <- NULL
            sem_out2@ParTable <- as.list(start3)
            sem_model <- sem_out2@Model
            sem_model <- update_model(sem_model, 
                                      start3[start3$free > 0, "est"] )
            sem_out2@Model <- sem_model
            std0 <- lavaan::standardizedSolution(sem_out2,
                                            type = "std.all",
                                            se = FALSE,
                                            zstat = FALSE,
                                            pvalue = FALSE,
                                            ci = FALSE,
                                            remove.eq = FALSE,
                                            remove.ineq = FALSE,
                                            remove.def = FALSE,
                                            output = "data.frame")
            k * std0[i, "est.std"]
          }
        lbci_b_grad <- function(param_depend, sem_out, debug, lav_warn) {
            param_depend_g <- param_depend
            attr(param_depend_g, "refit") <- FALSE 
            lavaan::lav_func_gradient_simple(lbci_b_f, param_depend_g, sem_out = sem_out, 
                                    debug = debug, lav_warn = lav_warn)
          }
        f_constr = set_constraint_nm(i_depend, sem_out, envir = envir0)
        # Set shared variables
        # lbci_b_grad <- NULL
        fit_lb <- rep(-Inf, length(i_depend))
        fit_ub <- rep( Inf, length(i_depend))
        fit_lb[find_variance_in_free(sem_out)[i_depend]] <- lb_i_var
        xstart <-  xstart[i_depend]
      }
    if ((i_op == ":=") && !test_generic) {
        if (standardized) {
          } else {
            # Get the name of the defined parameter
            i_name <- p_table[i, "label"]
            # The function to be minimized.
            i_depend <- find_dependent(i, sem_out = sem_out, standardized = FALSE)
            # Set shared variables
            envir0 <- new.env()
            assign("f_i_shared", sem_out, envir = envir0)
            assign("f_i_free_shared", sem_out, envir = envir0)
            # f_i_shared <- sem_out
            # f_i_free_shared <- sem_out
            # The function to be minimized.
            param_i <- rep(NA, npar)
            lbci_b_f <- function(param_depend, sem_out, debug, lav_warn) {
                force(i_depend)
                force(param_i)
                force(i_name)
                param_i[i_depend] <- param_depend
                k * sem_out@Model@def.function(param_i)[i_name]
              }
            # lbci_b_grad <- function(param_depend, sem_out, debug, lav_warn) {
            #     numDeriv::grad(lbci_b_f, param_depend, sem_out = sem_out, 
            #                             debug = debug, lav_warn = lav_warn)
            #   }
            lbci_b_grad <- function(param_depend, sem_out, debug, lav_warn) {
                force(i)
                force(envir0)
                force(i_depend)
                lavaan::lavTech(envir0$f_i_free_shared, "gradient")[i_depend]
              }
            # f_constr = set_constraint_nm(i_depend, sem_out)
            f_constr = set_constraint_nm(i_depend, sem_out, get_fit_from_envir = FALSE,
                                         envir = envir0)
            # lbci_b_grad <- NULL
            fit_lb <- rep(-Inf, length(i_depend))
            fit_ub <- rep( Inf, length(i_depend))
            fit_lb[find_variance_in_free(sem_out)[i_depend]] <- lb_var
            xstart <-  xstart[i_depend]
          }
      } else {
        if (!test_generic) {
          if (standardized) {
            } else {
              # Set shared variables
              envir0 <- new.env()
              assign("f_i_shared", sem_out, envir = envir0)
              assign("f_i_free_shared", sem_out, envir = envir0)
              # The function to be minimized.
              lbci_b_f <- function(p_f, sem_out, debug, lav_warn) {
                  k * p_f
                }
              # The gradient of the function to be minimized
              lbci_b_grad <- function(p_f, sem_out, debug, lav_warn) {
                  force(i)
                  force(envir0)
                  lavaan::lavTech(envir0$f_i_free_shared, "gradient")[i]
                }
              f_constr = set_constraint_nm(i, sem_out, get_fit_from_envir = FALSE,
                                          envir = envir0)
              # lbci_b_grad <- NULL
              fit_lb <- -Inf
              fit_ub <-  Inf
              xstart <-  xstart[i]
            }
        }
      }
    # fit_lb <- rep(-Inf, npar)
    # fit_lb[find_variance_in_free(sem_out)] <- lb_var
    opts_final <- modifyList(list("algorithm" = "NLOPT_LD_SLSQP",
                        "xtol_rel" = 1.0e-10,
                        "maxeval" = 1000,
                        "print_level" = 0),
                        opts)    
    out <- nloptr::nloptr(
                        x0 = xstart, 
                        eval_f = lbci_b_f, 
                        lb = fit_lb, # To-Do: Check
                        ub = fit_ub, # To-Do: Check
                        eval_grad_f = lbci_b_grad,
                        eval_g_eq = f_constr,
                        opts = opts_final,
                        sem_out = sem_out,
                        lav_warn = FALSE,
                        debug = FALSE)
    # bound <- k * out$objective
    bound <- i_est + k * out$objective
    bound_unchecked <- bound

    # Initialize the status code
    status <- 0

    # Check convergence
    if (out$status < 0) {
        # Verify the range that denotes error
        status <- 1
        bound <- NA
      }

    # Check the limit
    i_org_ci_limit <- switch(which,
                        lbound = i_org_ci_lower,
                        ubound = i_org_ci_upper)
    if (!is.na(bound)) {
        ci_limit_ratio <- abs((bound - i_est) / (i_org_ci_limit - i_est))
        if (ci_limit_ratio > ci_limit_ratio_tol) {
            status <- 1
            # Do not set the bound to NA because the limit may still be valid.
          }
      } else {
        ci_limit_ratio <- NA
      }

    # Check whether the solution at the limit is admissible
    start0 <- lavaan::parameterTable(sem_out)
    i_free <- find_free(sem_out)
    if (standardized) {
        fit_final <- envir0$f_i_shared
        fit_post_check <- lavaan::lavInspect(fit_final, "post.check")
      } else {
        if (i_op == ":=") {
            start0[which(i_free)[i_depend], "est"] <- out$solution
          } else {
            start0[i_free, "est"] <- out$solution
          }
        fit_final <- lavaan::update(sem_out, start = start0, do.fit = FALSE,
                                    check.start = TRUE,
                                    check.post = TRUE,
                                    check.vcov = TRUE)
        fit_post_check <- lavaan::lavInspect(fit_final, "post.check")
      }
    if (!fit_post_check) {
        status <- 0
        bound <- NA
        # The warning should be raised by the calling function, not this one
        # warning("Optimization converged but the final solution is not admissible.")
      }
    # TO DELETE
    # if (history) {
    #     attr(bound, "history") <- out
    #     attr(bound, "fit") <- envir0$f_i_shared
    #     attr(bound, "xstart") <- xstart
    #     attr(bound, "i_est") <- i_est
    #   }
    diag <- list(status = status,
                 est_org = i_est,
                 ci_org_limit = i_org_ci_limit,
                 ci_limit_ratio = ci_limit_ratio,
                 fit_post_check = fit_post_check,
                 start_values = xstart,
                 bound_unchecked = bound_unchecked
                 )
    if (verbose) {
        diag$history <- out
        diag$fit_final <- fit_final
      } else {
        diag$history <- NULL
        diag$fit_final <- NULL
      }
    if (out$status < 0) {
        # If convergence status < 0, override verbose
        diag$history <- out        
      }
    attr(bound, "diag") <- diag
    bound
  }
