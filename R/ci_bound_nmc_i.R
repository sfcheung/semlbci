#' @title Find the lower or upper bound for one parameter by
#'       the Neale-Miller-1997 approach using a model with constraints
#'
#' @description Find the lower or upper bound of the
#'              likelihood-based confidence interval (LBCI) for one parameter
#'              by the Neale-Miller-1997 approach  using a model with 
#'              constraints
#'
#' @details
#'
#' ## NOTE
#'
#' This function is not supposed to be used directly by users. It is
#' exported such that interested users can examine how a confidence bound is
#' found.
#'
#' ## Algorithm
#'
#' This function currently supports [lavaan::lavaan()] outputs only. This
#' function implements
#' a version of the algorithm presented in Neale and Miller (1997) that
#' use an equality constraint (see Pritikin, Rappaport, & Miller, 2017).
#' 
#' This function is different from [ci_bound_nmc()]. It modified the input 
#' model by adding one or more constraints.
#'
#' ## Limitation(s)
#'
#' This function not yet implements the method 
#'        for an estimate close to an attainable bound (see Pritikin, 
#'        Rappaport, & Miller, 2017).
#'
#' @return
#' A one-element numeric vector with the requested bound.
#'
#' The attribute `diag` contains basic information in the optimization process.
#' If `verbose` is `TRUE`, more information is stored in this attribute.
#'
#' @param i The position of the target parameters as in the parameter table of
#'          lavaan as generated by [lavaan::parameterTable()].
#' @param npar The number of free parameters, including those constrained to be
#'              equal.
#' @param sem_out The fit object. Currently supports a 
#'                [lavaan::lavaan-class] object only.
#' @param f_constr The constraint function generated by `set_constraint_nm`.
#'                 This argument is no longer used because the constraint
#'                  function will be
#'                  generated internally.
#' @param which Whether the lower bound or the upper bound is to be found. Must
#'              be `"lbound"` or `"ubound"`.
#' @param history If `TRUE`, return the full optimization output as an
#'                attribute. Default is `FALSE`.
#' @param perturbation_factor A number multiplied to the parameter
#'                            estimates in `sem_out`.
#'                            Using the parameter estimates as starting
#'                            values may lead to errors
#'                            in the first few iterations. Default is .90.
#'                            This argument is ignored is `wald_ci_start`
#'                            is `TRUE.
#' @param lb_var The lower bound for free parameters that are variances.
#'                Default is `-Inf`. This is not an admissible
#'                value but seems to be necessary when we need to find
#'                 the LBCI bound for a user-defined parameter.
#' @param wald_ci_start If `TRUE` and there are no equality constraints in
#'                      the model, Wald confidence limit will
#'                       be used as the starting value for the target parameter
#'                         if it is not a userd-defined paramter.
#' @param standardized If `TRUE`, the LBCI is for the requested estimate in the
#'                      standardized solution. Default is `FALSE`.
#' @param opts Options to be passed to [nloptr::nloptr()]. Default is `list()`
#' @param test_generic If `TRUE`, will use the generic functions that are
#'                     used for free parameters, user defined parameters, and
#'                     standardized solution. The generic functions are now
#'                     the only options.
#'                     Therefore, this argument will be ignored.
#' @param ciperc The proportion of coverage for the confidence interval. Default
#'               is .95.
#' @param ci_limit_ratio_tol The tolerance for the ratio of `a` to `b`,
#'                            where `a` is
#'                            the distance between an LBCI limit and the
#'               point estimate, and the `b` is the distance between the
#'                original confidence limit (by default the Wald CI in
#'               [lavaan::lavaan()])
#'               and the point estimate. If the ratio is larger than this value,
#'                a warning is set in the status code.
#'               Default is 1.5.
#' @param verbose If `TRUE`, the function will store more diagnostic information
#'                 in the attribute `diag`.
#'                Default is `FALSE`.
#' @param ... Optional arguments. Not used.
#'
#' @references
#'
#' Neale, M. C., & Miller, M. B. (1997). The use of likelihood-based confidence
#' intervals in genetic models. *Behavior Genetics, 27*(2), 113–120.
#' \url{https://doi.org/10.1023/A:1025681223921}
#'
#' Pritikin, J. N., Rappaport, L. M., & Neale, M. C. (2017). Likelihood-based
#' confidence intervals for a parameter with an upper or lower bound.
#' *Structural Equation Modeling: A Multidisciplinary Journal, 24*(3), 395–401.
#' \url{https://doi.org/10.1080/10705511.2016.1275969}
#'
#' @seealso
#' [semlbci()], [ci_i()]
#'
#' @examples
#' data(simple_med)
#' dat <- simple_med
#' mod <-
#' "
#' m ~ x
#' y ~ m
#' "
#' fit_med <- lavaan::sem(mod, simple_med, fixed.x = FALSE)
#'
#' out1l <- ci_bound_nmc_i(1, 5, sem_out = fit_med, which = "lbound")
#' out1l
#'
#' @export

ci_bound_nmc_i <- function(i = NULL, 
                       npar = NULL, 
                       sem_out = NULL,
                       f_constr = NULL, 
                       which = NULL,
                       history = FALSE,
                       perturbation_factor = .9,
                       lb_var = -Inf,
                       wald_ci_start = TRUE,
                       standardized = FALSE,
                       opts = list(),
                       test_generic = TRUE,
                       ciperc = .95,
                       ci_limit_ratio_tol = 1.5,
                       verbose = FALSE,
                       ...) {
    test_generic <- TRUE
    k <- switch(which,
                lbound = 1,
                ubound = -1)
    p_table <- lavaan::parameterTable(sem_out) 
    npar <- sum(p_table$free > 0)
    i_op <- p_table[i, "op"]
    i_lor <- get_lhs_op_rhs(i, sem_out, more = TRUE)
    i_labelled <- nchar(p_table[i, "label"]) > 0

    # Get original point estiamte and CI
    if (standardized) {
        p_est <- lavaan::standardizedSolution(sem_out,
                    type = "std.all",
                    se = TRUE,
                    zstat = FALSE,
                    pvalue = FALSE,
                    ci = TRUE,
                    remove.eq = FALSE,
                    remove.ineq = FALSE,
                    remove.def = FALSE,
                    output = "data.frame")
        i_est <- p_est[i, "est.std"]
        i_se <- p_est[i, "se"]
        i_org_ci_lower <- p_est[i, "ci.lower"]
        i_org_ci_upper <- p_est[i, "ci.upper"]
      } else {
        p_est <- lavaan::parameterEstimates(sem_out,
                                            se = TRUE,
                                            zstat = FALSE,
                                            fmi = FALSE,
                                            rsquare = TRUE,
                                            output = "data.frame")
        i_est <- p_est[i, "est"]
        i_se <- p_est[i, "se"]
        i_org_ci_lower <- p_est[i, "ci.lower"]
        i_org_ci_upper <- p_est[i, "ci.upper"]
      }

    p_table_fit <- p_table

    # Unstandardized
    # Check if labelled
    if (standardized) {
        i_label <- gen_unique_name(get_names_from_ptable(p_table_fit))

        lbci_b_f <- function(x) {
            # force(i_est)
            # k * x - i_est
            x
          }

        lbci_b_grad <- function(x) {
            1
          }

        gen_fct <- function(fit, i) {
            force(fit)
            force(i)
            fit_pt <- lavaan::parameterTable(fit)
            tmpfct <- function(...) {
                force(fit)
                force(i)
                force(fit_pt)
                .x. <- get(".x.", envir = parent.frame())
                fit@Model <- lavaan::lav_model_set_parameters(
                                  fit@Model, .x.
                                )
                fit_pt2 <- fit_pt
                fit_pt2[fit_pt$free > 0, "est"] <- .x.
                fit@ParTable <- as.list(fit_pt2)
                std <- lavaan::standardizedSolution(
                                  fit,
                                  se = FALSE)
                std[i, "est.std"]
              }
            return(tmpfct)
          }
        geteststd <<- gen_fct(fit = sem_out, i = i)

        n <- as.numeric(lavaan::fitMeasures(sem_out, "chisq") /
              (2 * lavaan::lavTech(sem_out, "optim")$fx))
        qcrit <- stats::qchisq(ciperc, 1)
        target <- lavaan::lavTech(sem_out, "optim")$fx + qcrit / (2 * n)
        fit0 <- lavaan::update(sem_out,
                               add = c(paste0(i_label, " := geteststd()"),
                                       paste0(i_label, " == ", i_est - k * i_se)),
                               do.fit = FALSE,
                               baseline = FALSE,
                               h1 = FALSE)
        p_table0 <- lavaan::parameterTable(fit0)
        i_constr <- which(p_table0$lhs == i_label & p_table0$op == "==")

        f_constr1 <- function(x, more_options = list()) {
            force(p_table0)
            force(target)
            force(fit0)
            force(i_constr)
            force(i_est)
            force(k)
            force(geteststd)
            p_table0[i_constr, "rhs"] <- i_est + k * x
            fit <- lavaan::update(fit0, p_table0,
                                  baseline = FALSE,
                                  h1 = FALSE,
                                  se = "none",
                                  # implied = FALSE,
                                  do.fit = TRUE,
                                  verbose = FALSE)
            if (isTRUE(more_options$fit)) {
                return(fit)
              }
            lavaan::lavTech(fit, "optim")$fx - target
          }

        f_constr2 <- function(x) {
            lavaan::lav_func_gradient_simple(f_constr1, x)
          }

        f_constr <- function(x) {
            list(
                constraints = rbind(f_constr1(x)),
                jacobian = rbind(f_constr2(x))
              )
          }
      } else {
        if (!i_labelled) {
            i_label <- gen_unique_name(get_names_from_ptable(p_table_fit))
            p_table_fit[i, "label"] <- i_label
          } else {
            i_label <- p_table_fit[i, "label"]
          }

        lbci_b_f <- function(x) {
            # force(i_est)
            # k * x - i_est
            x
          }

        lbci_b_grad <- function(x) {
            1
          }

        n <- as.numeric(lavaan::fitMeasures(sem_out, "chisq") / 
              (2 * lavaan::lavTech(sem_out, "optim")$fx))
        qcrit <- stats::qchisq(ciperc, 1)
        target <- lavaan::lavTech(sem_out, "optim")$fx + qcrit / (2 * n)
        # This should work for both free parameters and user-defined parameters
        # TODO: Consider this function: lav_partable_add
        fit0 <- lavaan::update(sem_out, model = p_table_fit,
                               add = paste0(i_label, " == ", i_est - k * i_se),
                               do.fit = FALSE,
                               baseline = FALSE,
                               h1 = FALSE)
        p_table0 <- lavaan::parameterTable(fit0)
        # Not sure why we have to manually set this constraint to free
        p_table0[p_table0$lhs == i_label, "free"] <- 0
        i_constr <- which(p_table0$lhs == i_label & p_table0$op == "==")

        f_constr1 <- function(x, more_options = list()) {
            force(p_table0)
            force(target)
            force(fit0)
            force(i_constr)
            force(i_est)
            force(k)
            p_table0[i_constr, "rhs"] <- i_est + k * x
            fit <- lavaan::update(fit0, p_table0,
                                  baseline = FALSE,
                                  h1 = FALSE,
                                  se = "none",
                                  # implied = FALSE,
                                  do.fit = TRUE,
                                  verbose = FALSE)
            if (isTRUE(more_options$fit)) {
                return(fit)
              }
            lavaan::lavTech(fit, "optim")$fx - target
          }

        f_constr2 <- function(x) {
            lavaan::lav_func_gradient_simple(f_constr1, x)
          }

        f_constr <- function(x) {
            list(
                constraints = rbind(f_constr1(x)),
                jacobian = rbind(f_constr2(x))
              )
          }

      }

    # Set starting values
    if (wald_ci_start) {
        xstart <- -1 * switch(which,
                          lbound = i_est - i_org_ci_lower,
                          ubound = i_org_ci_upper - i_est)
      } else {
        xstart <- perturbation_factor * i_est
      }

    # Set the boundaries
    fit_lb <- -Inf
    fit_ub <- 0

    opts_final <- utils::modifyList(list("algorithm" = "NLOPT_LD_SLSQP",
                        "xtol_rel" = 1.0e-10,
                        "maxeval" = 1000,
                        "print_level" = 3),
                        opts)
    # out <- nloptr::slsqp(
    #              x0 = xstart,
    #              fn = lbci_b_f,
    #              gr = lbci_b_grad,
    #              upper = fit_ub,
    #              heq = f_constr1,
    #              nl.info = TRUE,
    #              control = opts)
    out <- nloptr::nloptr(
                        x0 = xstart, 
                        eval_f = lbci_b_f, 
                        lb = fit_lb,
                        ub = fit_ub,
                        eval_grad_f = lbci_b_grad,
                        eval_g_eq = f_constr,
                        opts = opts_final
                    )
    bound <- i_est + k * out$objective
    bound_unchecked <- bound

    # Check p-value
    fit_final <- f_constr1(out$objective, more_options = list(fit = TRUE))
    fit_org   <- lavaan::update(sem_out, model = p_table_fit)
    lavaan::anova(fit_final, fit_org)

    # Initialize the status code
    status <- 0

    # Check convergence
    if (out$status < 0) {
        # Verify the range that denotes error
        status <- 1
        bound <- NA
      }

    # Check the limit
    i_org_ci_limit <- switch(which,
                        lbound = i_org_ci_lower,
                        ubound = i_org_ci_upper)
    if (!is.na(bound)) {
        ci_limit_ratio <- abs((bound - i_est) / (i_org_ci_limit - i_est))
        if (ci_limit_ratio > ci_limit_ratio_tol) {
            status <- 1
            # Do not set the bound to NA because the limit may still be valid.
          }
      } else {
        ci_limit_ratio <- NA
      }

    # Check whether the solution at the limit is admissible
    start0 <- lavaan::parameterTable(sem_out)
    i_free <- find_free(sem_out)
    if (TRUE) {
        fit_post_check <- lavaan::lavInspect(fit_final, "post.check")
      } else {
        # TO DELETE
        # if (i_op == ":=") {
            # start0[which(i_free)[i_depend], "est"] <- out$solution
          # } else {
            # start0[i_free, "est"] <- out$solution
          # }
        # fit_final <- lavaan::update(sem_out, start = start0, do.fit = FALSE,
        #                             check.start = TRUE,
        #                             check.post = TRUE,
        #                             check.vcov = TRUE)
        # fit_post_check <- lavaan::lavInspect(fit_final, "post.check")
      }
    if (!fit_post_check) {
        status <- 0
        bound <- NA
        # The warning should be raised by the calling function, not this one
        # warning("Optimization converged but the final solution is not admissible.")
      }

    diag <- list(status = status,
                 est_org = i_est,
                 ci_org_limit = i_org_ci_limit,
                 ci_limit_ratio = ci_limit_ratio,
                 fit_post_check = fit_post_check,
                 start_values = xstart,
                 bound_unchecked = bound_unchecked
                 )
    if (verbose) {
        diag$history <- out
        diag$fit_final <- fit_final
      } else {
        diag$history <- NULL
        diag$fit_final <- NULL
      }
    if (out$status < 0) {
        # If convergence status < 0, override verbose
        diag$history <- out        
      }
    attr(bound, "diag") <- diag
    bound
  }
