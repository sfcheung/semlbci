#'@title Find the lower or upper bound of the LBCI for one parameter
#'
#'@description Find the lower or upper bound of the likelihood-based
#'             confidence interval (LBCI) for one parameter
#'
#'@details
#'
#' ## NOTE 1
#' 
#' This function is no longer the default function used by [semlbci()].
#' This function works, but has not been updated. The default and preferred
#' function is [ci_bound_nm_i()], which uses the approacy by Neale and Miller 
#' (1997).
#' 
#' ## NOTE 2
#' 
#' This function is not supposed to be used directly by users. It is
#' exported such that interested users can examine how a confidence bound is
#' found.
#' 
#' ## Algorithm
#' 
#' This function currently supports [lavaan::lavaan()] outputs only. This
#' function implements
#' the algorithm presented in Wu and Neale (2012; see also Pek & Wu, 2015,
#' Equation 12) that
#' estimates all free parameters in the optimization.
#' 
#' ## Limitation(s)
#' 
#' This function not yet implements the method by Wu and Neale (2012)
#'        for an estimate close to an attainable bound.
#'
#'@return
#' The requested bound.
#' 
#' The attribute `diag` contains basic information in the optimization process.
#' If `verbose` is `TRUE`, more information will be stored in this attribute.
#'
#' @param i The position of the target parameters as in the parameter table of 
#'          lavaan as generated by [lavaan::parameterTable()].
#' @param npar The number of free parameters, including those constrained to be 
#'              equal.
#' @param sem_out The fit object. Currently supports an [lavaan::lavaan()] output only. 
#' @param f_constr The constraint function generated by [set_constraint()].
#' @param which Whether the lower bound or the upper bound is to be found. Must 
#'              be `"lbound"` or `"ubound"`.
#' @param history If `TRUE`, return the full optimization output as an 
#'                attribute. Default is `FALSE`.
#' @param perturbation_factor A number multiplied to the parameter 
#'                            estimates in `sem_out`.
#'                            Using the parameter estimates as starting 
#'                            values may lead to errors
#'                            in the first few iterations. Default is .90.
#'                            This argument is ignored is `wald_ci_start` 
#'                            is `TRUE.
#' @param lb_var The lower bound for free parameters that are variances. 
#'                Default is `-Inf`. This is not an admissible
#'                value but seems to be necessary when we need to find 
#'                 the LBCI bound for a user-defined parameter.
#' @param wald_ci_start If `TRUE` and there are no equality constraints in 
#'                      the model, Wald confidence limit will
#'                       be used as the starting value for the target parameter
#'                         if it is not a userd-defined paramter.
#' @param standardized If `TRUE`, the LBCI is for the requested estimate in the 
#'                      standardized solution. Default is `FALSE`.
#' @param opts Options to be passed to [nloptr::nloptr()]. Default is `list()`
#' @param ci_limit_ratio_tol The tolerance for the ratio of `a` to `b`, 
#'                            where `a` is 
#'                            the distance between an LBCI limit and the 
#'               point estimate, and the `b` is the distance between the 
#'                original confidence limit (by default the Wald CI in
#'               [lavaan::lavaan()])
#'               and the point estimate. If the ratio is larger than this value,
#'                a warning is set in the status code.
#'               Default is 1.5.
#' @param verbose If `TRUE`, the function will store more diagnostic information
#'                 in the attribute `diag`.
#'                Default is `FALSE`.
#' @param ... Optional arguments. Not used.
#' 
#' @references 
#' 
#' Pek, J., & Wu, H. (2015). Profile likelihood-based confidence intervals and 
#'  regions for structural equation models. *Psychometrika, 80*(4), 1123–1145. 
#'  \url{https://doi.org/10.1007/s11336-015-9461-1}
#'
#' Wu, H., & Neale, M. C. (2012). Adjusted confidence intervals for a bounded
#'  parameter. *Behavior Genetics, 42*(6), 886–898. 
#'  \url{https://doi.org/10.1007/s10519-012-9560-z}
#' 
#' 
#'@examples
#' data(simple_med)
#' dat <- simple_med
#' mod <-
#' "
#' m ~ x
#' y ~ m
#' "
#' fit_med <- lavaan::sem(mod, simple_med, fixed.x = FALSE)
#' 
#' fn_constr0 <- set_constraint(fit_med)
#' 
#' out1l <- ci_bound_i(1, 5, sem_out = fit_med, f_constr = fn_constr0, which = "lbound")
#' out1l
#' 
#'@export

ci_bound_i <- function(i = NULL, 
                       npar = NULL, 
                       sem_out = NULL,
                       f_constr = NULL, 
                       which = NULL,
                       history = FALSE,
                       perturbation_factor = .9,
                       lb_var = -Inf,
                       wald_ci_start = TRUE,
                       standardized = FALSE,
                       opts = list(),
                       ci_limit_ratio_tol = 1.5,
                       verbose = FALSE,
                       ...) {
    k <- switch(which,
                lbound = 1,
                ubound = -1)
    # Check if the parameter is a user-defined parameter
    p_table <- lavaan::parameterTable(sem_out) 
    i_op <- p_table[i, "op"]

    # Get original point estiamte and CI
    if (standardized) {
        p_est <- lavaan::standardizedSolution(sem_out,
                    type = "std.all",
                    se = TRUE,
                    zstat = FALSE,
                    pvalue = FALSE,
                    ci = TRUE,
                    remove.eq = FALSE,
                    remove.ineq = FALSE,
                    remove.def = FALSE,
                    output = "data.frame")
        i_est <- p_est[i, "est.std"]
        i_org_ci_lower <- p_est[i, "ci.lower"]
        i_org_ci_upper <- p_est[i, "ci.upper"]
      } else {
        p_est <- lavaan::parameterEstimates(sem_out,
                                            se = TRUE,
                                            zstat = FALSE,
                                            fmi = FALSE,
                                            rsquare = TRUE,
                                            output = "data.frame")
        i_est <- p_est[i, "est"]
        i_org_ci_lower <- p_est[i, "ci.lower"]
        i_org_ci_upper <- p_est[i, "ci.upper"]
      }

    if (standardized && (i_op %in% c("=~", "~", "~~", ":="))) {
        p_std <- lavaan::standardizedSolution(sem_out,
                                              type = "std.all",
                                              se = FALSE,
                                              zstat = FALSE,
                                              pvalue = FALSE,
                                              ci = FALSE,
                                              remove.eq = FALSE,
                                              remove.ineq = FALSE,
                                              remove.def = FALSE,
                                              output = "data.frame")
        p_std$id <- seq_len(nrow(p_std))
        i_lor <- get_lhs_op_rhs(i, sem_out)
        i_std <- merge(p_std, i_lor, by = c("lhs", "op", "rhs"))$id
        start0 <- lavaan::parameterTable(sem_out)
        # The function to be minimized.
        lbci_b_f <- function(param, sem_out, debug, lav_warn) {
            start1 <- start0
            start1[start1$free > 0, "est"] <- param
            sem_out2 <- sem_out
            sem_out2@ParTable <- as.list(start1)
            sem_model <- sem_out2@Model
            sem_model <- update_model(sem_model, 
                                      start1[start1$free > 0, "est"] )
            sem_out2@Model <- sem_model
            std0 <- lavaan::standardizedSolution(sem_out2,
                                            type = "std.all",
                                            se = FALSE,
                                            zstat = FALSE,
                                            pvalue = FALSE,
                                            ci = FALSE,
                                            remove.eq = FALSE,
                                            remove.ineq = FALSE,
                                            remove.def = FALSE,
                                            output = "data.frame")
            k * std0[i_std, "est.std"]
          }
        # The gradient of the function to be minimized
        lbci_b_grad <- function(param, sem_out, debug, lav_warn) {
            numDeriv::grad(lbci_b_f, param, sem_out = sem_out, 
                                    debug = debug, lav_warn = lav_warn)
          }
      }
    if (i_op == ":=") {
        if (standardized) {
          } else {
            # Get the name of the defined parameter
            i_name <- p_table[i, "label"]
            # The function to be minimized.
            lbci_b_f <- function(param, sem_out, debug, lav_warn) {
                k * sem_out@Model@def.function(param)[i_name]
              }
            # The gradient of the function to be minimized
            lbci_b_grad <- function(param, sem_out, debug, lav_warn) {
                numDeriv::grad(lbci_b_f, param, sem_out = sem_out, 
                                        debug = debug, lav_warn = lav_warn)
              }            
          }
      } else {
        if (standardized) {
          } else {
            # The function to be minimized.
            lbci_b_f <- function(param, sem_out, debug, lav_warn) {
                k * param[i]
              }
            # The gradient of the function to be minimized
            grad_c <- rep(0, npar)
            grad_c[i] <- k
            lbci_b_grad <- function(param, sem_out, debug, lav_warn) {
                    grad_c
              }
          }
      }
    if (wald_ci_start & !sem_out@Model@eq.constraints) {
        if (i_op == ":=") {
              xstart <- set_start(i, sem_out, which)
              xstart <- xstart[xstart$free > 0, "est"]
            } else {
              if (standardized) {
                  xstart <- set_start(i, sem_out, which, standardized)
                  xstart <- xstart[xstart$free > 0, "est"]
                } else {
                  xstart <- set_start(i, sem_out, which)
                  xstart <- xstart[xstart$free > 0, "est"]
                }
            } 
      } else {
        xstart <- perturbation_factor * lavaan::coef(sem_out)
      }
    fit_lb <- rep(-Inf, npar)
    fit_lb[find_variance_in_free(sem_out)] <- lb_var
    opts_final <- modifyList(list("algorithm" = "NLOPT_LD_SLSQP",
                        "xtol_rel" = 1.0e-10,
                        "maxeval" = 1000,
                        "print_level" = 0),
                        opts)    
    out <- nloptr::nloptr(
                        x0 = xstart, 
                        eval_f = lbci_b_f, 
                        lb = fit_lb, # To-Do: Check
                        ub = rep( Inf, npar), # To-Do: Check
                        eval_grad_f = lbci_b_grad,
                        eval_g_eq = f_constr,
                        opts = opts_final,
                        sem_out = sem_out,
                        lav_warn = FALSE,
                        debug = FALSE)
    bound <- k * out$objective
    bound_unchecked <- bound

    # Initialize the status code
    status <- 0

    # Check convergence
    if (out$status < 0) {
        # Verify the range that denotes error
        status <- 1
        bound <- NA
      }

    # Check the limit
    i_org_ci_limit <- switch(which,
                        lbound = i_org_ci_lower,
                        ubound = i_org_ci_upper)
    if (!is.na(bound)) {
        ci_limit_ratio <- abs((bound - i_est) / (i_org_ci_limit - i_est))
        if (ci_limit_ratio > ci_limit_ratio_tol) {
            status <- 1
            # Do not set the bound to NA because the limit may still be valid.
          }
      } else {
        ci_limit_ratio <- NA
      }

    # Check whether admissible
    start0 <- lavaan::parameterTable(sem_out)
    i_free <- find_free(sem_out)
    start0[i_free, "est"] <- out$solution
    fit_final <- lavaan::update(sem_out, start = start0, do.fit = FALSE,
                                check.start = TRUE,
                                check.post = TRUE,
                                check.vcov = TRUE)
    fit_post_check <- lavaan::lavInspect(fit_final, "post.check")
    if (!fit_post_check) {
        status <- 0
        bound <- NA
        # The warning should be raised by the calling function, not this one
        # warning("Optimization converged but the final solution is not admissible.")
      }
    diag <- list(status = status,
                 est_org = i_est,
                 ci_org_limit = i_org_ci_limit,
                 ci_limit_ratio = ci_limit_ratio,
                 fit_post_check = fit_post_check,
                 start_values = xstart,
                 bound_unchecked = bound_unchecked
                 )
    if (verbose) {
        diag$history <- out
        diag$fit_final <- fit_final
      } else {
        diag$history <- NULL
        diag$fit_final <- NULL
      }
    if (out$status < 0) {
        # If convergence status < 0, override verbose
        diag$history <- out        
      }
    attr(bound, "diag") <- diag
    bound
  }
