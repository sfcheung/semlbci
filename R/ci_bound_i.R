#'@title Find the lower or upper bound for one parameter
#'
#'@description Find the lower or upper bound for one parameter.
#'
#'@details
#'
#' Currently supports \code{lavaan} output only.
#'
#'@return
#' The requested bound.
#' Can return the optimization history as an attribute.
#'
#' @param i The position of the target parameters as in the parameter table of lavaan.
#' @param npar The number of free parameters, including those constrained to be equal.
#' @param sem_out The fit object.
#' @param f_constr The constraint function generated by \code{set_constraint}.
#' @param which Whether the lower bound or the upper bound is to be found. Must be "lbound" or "ubound".
#' @param history If \code{TRUE}, return the full optimization output as an attribute. Default is \code{FALSE}.
#' @param opts Options to be passed to \code{nloptr}
#' 
#'@examples
#' library(lavaan)
#' data(cfa_two_factors)
#' mod <-
#' "
#' f1 =~ x1 + x2 + a*x3
#' f2 =~ x4 + a*x5 + equal('f1=~x2')*x6
#' f1 ~~ 0*f2
#' asq := a^2
#' "
#' fit <- sem(mod, cfa_two_factors)
#'@export

ci_bound_i <- function(i = NULL, 
                       npar = NULL, 
                       sem_out = NULL,
                       f_constr = NULL, 
                       which = NULL,
                       history = FALSE,
                       opts = list(
                          "algorithm" = "NLOPT_LD_SLSQP",
                          "xtol_rel" = 1.0e-10,
                          "maxeval" = 1000,
                          "print_level" = 0,
                          "local_opts" = list("algorithm" = "NLOPT_LD_SLSQP",
                                              "xtol_rel"  = 1.0e-10,
                                              "maxeval" = 1000,
                                              "print_level" = 0)),
                       ...) {
    k <- switch(which,
                lbound = 1,
                ubound = -1)
    # Check if the parameter is a user-defined parameter
    p_table <- lavaan::parameterTable(sem_out) 
    i_op <- p_table[i, "op"]
    if (i_op == ":=") {
        # Get the name of the defined parameter
        i_name <- p_table[i, "label"]
        # The function to be minimized.
        lbci_b_f <- function(param, sem_out, debug, lav_warn) {
            start0 <- lavaan::parameterTable(sem_out)
            start0[find_free(sem_out), "est"] <- param
            if (lav_warn) {
                    fit2 <- lavaan::update(sem_out, start = start0, do.fit = FALSE)
                } else {
                    suppressWarnings(fit2 <- lavaan::update(sem_out, start = start0, do.fit = FALSE))                    
                }
            k * fit2@Model@def.function(lavaan::coef(fit2))[i_name]
          }
        # The gradient of the function to be minimized
        lbci_b_grad <- function(param, sem_out, debug, lav_warn) {
            numDeriv::grad(lbci_b_f, param, sem_out = sem_out, 
                                     debug = debug, lav_warn = lav_warn)
          }
      } else {
        # The function to be minimized.
        lbci_b_f <- function(param, sem_out, debug, lav_warn) {
            k * param[i]
          }
        # The gradient of the function to be minimized
        grad_c <- rep(0, npar)
        grad_c[i] <- k
        lbci_b_grad <- function(param, sem_out, debug, lav_warn) {
                grad_c
          }
      }
    out <- nloptr::nloptr(
                        x0 = stats::runif(npar, .8, 1.2) *
                          lavaan::coef(environment(f_constr)$sem_out), 
                        eval_f = lbci_b_f, 
                        lb = rep(-Inf, npar), # To-Do: Check
                        ub = rep( Inf, npar), # To-Do: Check
                        eval_grad_f = lbci_b_grad,
                        eval_g_eq = f_constr,
                        opts = opts,
                        sem_out = sem_out,
                        lav_warn = FALSE,
                        debug = FALSE)
    bound <- k * out$objective
    if (history) {
        attr(bound, "history") <- out
      }
    bound
  }
